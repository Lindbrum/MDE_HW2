package UniStudy.constraints;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.base.BaseConstraintsDescriptor;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.runtime.ReferenceConstraintsDescriptor;
import jetbrains.mps.smodel.runtime.base.BaseReferenceConstraintsDescriptor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.Objects;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class ExaminationCallReference_Constraints extends BaseConstraintsDescriptor {
  public ExaminationCallReference_Constraints() {
    super(CONCEPTS.ExaminationCallReference$Xm);
  }

  @Override
  protected Map<SReferenceLink, ReferenceConstraintsDescriptor> getSpecifiedReferences() {
    BaseReferenceConstraintsDescriptor d0 = new BaseReferenceConstraintsDescriptor(LINKS.call$Aa5Q, this, false, true) {
      @Override
      public boolean validate(final SNode referenceNode, final SNode oldReferentNode, final SNode newReferentNode) {
        return true;
      }
      @Override
      public void onReferenceSet(final SNode referenceNode, final SNode oldReferentNode, final SNode newReferentNode) {
        {
          final SNode student = SNodeOperations.getParent(referenceNode);
          if (SNodeOperations.isInstanceOf(student, CONCEPTS.Student$Dd)) {
            ListSequence.fromList(SLinkOperations.getChildren(newReferentNode, LINKS.booked_students$C1Ek)).addElement(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6d0cfce3b6ce4188L, 0xa63493977a58376fL, 0x13cf5a8b21e5c413L, "UniStudy.structure.StudentReference")));
            SLinkOperations.setTarget(ListSequence.fromList(SLinkOperations.getChildren(newReferentNode, LINKS.booked_students$C1Ek)).last(), LINKS.student$_OLQ, student);
            if ((oldReferentNode != null)) {
              ListSequence.fromList(SLinkOperations.getChildren(oldReferentNode, LINKS.booked_students$C1Ek)).removeWhere((it) -> Objects.equals(SLinkOperations.getTarget(it, LINKS.student$_OLQ), student));
            }
          }
        }
        SLinkOperations.setTarget(referenceNode, LINKS.call$Aa5Q, newReferentNode);
      }
    };
    Map<SReferenceLink, ReferenceConstraintsDescriptor> references = new HashMap<SReferenceLink, ReferenceConstraintsDescriptor>();
    references.put(d0.getReference(), d0);
    return references;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ExaminationCallReference$Xm = MetaAdapterFactory.getConcept(0x6d0cfce3b6ce4188L, 0xa63493977a58376fL, 0x13cf5a8b21e5c42cL, "UniStudy.structure.ExaminationCallReference");
    /*package*/ static final SConcept Student$Dd = MetaAdapterFactory.getConcept(0x6d0cfce3b6ce4188L, 0xa63493977a58376fL, 0x78359f29b5c5cfe1L, "UniStudy.structure.Student");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink call$Aa5Q = MetaAdapterFactory.getReferenceLink(0x6d0cfce3b6ce4188L, 0xa63493977a58376fL, 0x13cf5a8b21e5c42cL, 0x13cf5a8b21e5c42dL, "call");
    /*package*/ static final SContainmentLink booked_students$C1Ek = MetaAdapterFactory.getContainmentLink(0x6d0cfce3b6ce4188L, 0xa63493977a58376fL, 0x78359f29b5c57a20L, 0x13cf5a8b21e5c416L, "booked_students");
    /*package*/ static final SReferenceLink student$_OLQ = MetaAdapterFactory.getReferenceLink(0x6d0cfce3b6ce4188L, 0xa63493977a58376fL, 0x13cf5a8b21e5c413L, 0x13cf5a8b21e5c414L, "student");
  }
}
